---
description: Creation of a single execution path with multiple nodes
---

# Event pipeline

## Introduction

The goal is to create an execution path where a node is invoked after a parent node has processed an event.

The [@OnEvent](https://github.com/v12technology/fluxtion/blob/master/builder/src/main/java/com/fluxtion/api/annotations/OnEvent.java)  annotation marks a method to be included in the execution graph. The method will be invoked when all of its dependent nodes on the execution path have processed the event. Event processing includes @OnEvent and @EventHandler annotated methods of parents.

{% hint style="info" %}
Only methods marked with **@OnEvent** will be included in the execution graph
{% endhint %}

A valid OnEvent method has no arguments with an optional boolean return type. The boolean return indicates whether this node is "dirty" and event notification should continue, change notifications are [discussed later](dirty-node-monitoring.md).

The example below defines a `PipelineNode` that is  dependent upon a `DataEventHandler`. The DataEventHandler processes DataEvent's as an event handler.

```java
public class PipelineNode {

    private final DataEventHandler handler;

    public PipelineNode(DataEventHandler handler) {
        this.handler = handler;
    }
    
    @OnEvent
    public void update(){}
}
```

The update method will be invoked by the SEP in topological order after the DataHandler has processed an incoming event. We define the graph imperatively using a builder class, further discussion on builders is in the [graph building](../graph-building-primitives/) section.

```java
public class Builder extends SEPConfig {

    @Override
    public void buildConfig() {
        DataEventHandler handler = new DataEventHandler();
        PipelineNode node = new PipelineNode(handler);
        addNode(handler);
        addNode(node);
    }

}
```

## Example

The pipeline example is [here](https://github.com/v12technology/fluxtion/tree/master/examples/documentation-examples/src/main/java/com/fluxtion/example/core/events/pipeline).

#### Generated SEP

The generated SEP, implements a dispatch method invoking the execution path in topological order

```java
public class SampleProcessor implements EventHandler, BatchHandler, Lifecycle {

  //Node declarations
  private final DataEventHandler dataEventHandler_1 = new DataEventHandler();
  private final PipelineNode pipelineNode_3 = new PipelineNode(dataEventHandler_1);
  
  public SampleProcessor() {}

//omitted code for clarity

  public void handleEvent(DataEvent typedEvent) {
    //Default, no filter methods
    dataEventHandler_1.handleEvent(typedEvent);
    pipelineNode_3.update();
    //event stack unwind callbacks
    afterEvent();
  }

}

```

 The graphical representation of this execution graph as generated by Fluxtion ESC:

![execution graph for a simple pipeline system](../../.gitbook/assets/sampleprocessor%20%285%29.png)

As described in [structured processing](../developer/auditing.md), the elements in the image are consistent with the generated code. For example the variable name of the PipelineNode is pipelineNode\_3 in both the image and the generated SEP.

