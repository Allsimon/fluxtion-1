---
description: Be notified when a parent does not notify of change
---

# Clean node monitoring

The goal is to provide if-else functionality for dirty change listeners.

Sometimes we want to provide an either or style functionality on change listeners. Register a listener to a node that fires when the parent node indicates it is clean \(or not "dirty"\). This the opposite behaviour to [dirty node monitoring](dirty-node-monitoring.md). Take the example of the breach indicator we may want behaviours when the limit is breached or when it is not.

#### Example

We create an event handler that issues a change notification flag. We connect three listener to this each with different behaviours depending upon the dirty flag status of the parent. The listeners are:

<table>
  <thead>
    <tr>
      <th style="text-align:left">Node</th>
      <th style="text-align:left">Behaviour</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align:left">DirtyListener</td>
      <td style="text-align:left">changeUpdate() invoked when the parent indicates a change</td>
    </tr>
    <tr>
      <td style="text-align:left">CleanListener</td>
      <td style="text-align:left">noChangeUpdate() invoked when parent indicates no change</td>
    </tr>
    <tr>
      <td style="text-align:left">DirtyCleanListener</td>
      <td style="text-align:left">
        <p>Combines clean and dirty listeners into one class:</p>
        <p>changeUpdate() invoked when the parent indicates a change</p>
      </td>
    </tr>
  </tbody>
</table>The change listeners:

```java
public class CleanListener {

    private final Object parent;
    
    @OnEvent(dirty = false)
    public void noChangeUpdate() {

    }

}

public class DirtyListener {
   
    private final Object parent;

    @OnEvent
    public void changeUpdate() {

    } 
}

public class DirtyCleanListener {
       
    private final Object parent;

    @OnEvent
    public void changeUpdate() {

    } 
    
    @OnEvent(dirty = false)
    public void noChangeUpdate() {

    }
}
```

#### Generated SEP

The dispatch method inverts the return type from the parent node when the child is listening for "clean" parents. As we expect there are four callback methods in the dispatch.

```java
public class SampleProcessor implements EventHandler, BatchHandler, Lifecycle {

  //Node declarations
  private final ConditioningHandler conditioningHandler_1 = new ConditioningHandler();
  private final CleanListener cleanListener_3 = new CleanListener(conditioningHandler_1);
  private final DirtyCleanListener dirtyCleanListener_7 =
      new DirtyCleanListener(conditioningHandler_1);
  private final DirtyListener dirtyListener_5 = new DirtyListener(conditioningHandler_1);
  //Dirty flags
  private boolean isDirty_conditioningHandler_1 = false;
  //Filter constants

  public SampleProcessor() {}

  public void handleEvent(MyEvent typedEvent) {
    //Default, no filter methods
    isDirty_conditioningHandler_1 = conditioningHandler_1.onEvent(typedEvent);
    if (!isDirty_conditioningHandler_1) {
      cleanListener_3.noChangeUpdate();
    }
    if (isDirty_conditioningHandler_1) {
      dirtyCleanListener_7.changeUpdate();
    }
    if (!isDirty_conditioningHandler_1) {
      dirtyCleanListener_7.noChangeUpdate();
    }
    if (isDirty_conditioningHandler_1) {
      dirtyListener_5.changeUpdate();
    }
    //event stack unwind callbacks
    afterEvent();
  }

  @Override
  public void afterEvent() {

    isDirty_conditioningHandler_1 = false;
  }

}
```

 The graphical representation of this execution graph as generated by Fluxtion ESC:

![Sample SEP for clean and dirty listeners](../../.gitbook/assets/sampleprocessor%20%282%29.png)

