---
description: Enable a node to invert the execution path and push data to a parent
---

# Push node reference

The goal is to invert the execution path order of two nodes. This allows a child node to push data to a parent node before the parent node OnEvent method is invoked.

Sometimes we want to push data to a shared node for reading by another node. The problem can occur if the read node is not dependent upon the write node, as reader and writer are siblings their order in the execution path is not guaranteed. We could force the reader to artificially create a dependency upon the writer. Again we want to move this error prone operation into the framework if possible. If the writer specifies the parent node as a push reference then no reader will need to worry about execution order. The push creates an implicit dependency between reader and writer without the reader specifying anything and the processing will behave as expected.

We use the [@PushReference](https://github.com/v12technology/fluxtion/blob/master/builder/src/main/java/com/fluxtion/api/annotations/PushReference.java) to mark a parent node as an inverted execution dependency.

#### Example

In this example we create a cache as a shared node, with a cache reader and cache writer. The reader and writer are siblings with no explicit dependency. We use the @PushReference annotation in the writer to mark the cache as a push destination.

The node classes

```java
public class Cache {
    
    @OnEvent
    public void reconcileCache(){
        
    }
}


public class CacheWriter {
    
    @PushReference
    public Cache cache;
    private final MyEventHandler handler;

    public CacheWriter(MyEventHandler handler) {
        this.handler = handler;
    }

    public CacheWriter(Cache cache, MyEventHandler handler) {
        this.cache = cache;
        this.handler = handler;
    }
    
    @OnEvent
    public void pushToCache(){
        
    }
    
}


public class CacheReader {

    private final Cache cache;
    private final MyEventHandler handler;

    public CacheReader(Cache cache, MyEventHandler handler) {
        this.cache = cache;
        this.handler = handler;
    }

    @OnEvent
    public void readFromCache() {

    }
}
```

 The builder class used to declare the processing graph:

```java
public class Builder extends SEPConfig {

    @Override
    public void buildConfig() {
        MyEventHandler myHandler = addNode(new MyEventHandler());
        Cache cache = addNode(new Cache());
        CacheReader cacheReader = addNode(new CacheReader(cache, myHandler));
        CacheWriter cacheWriter = addNode(new CacheWriter(cache, myHandler));
    }

}
```

#### Generated SEP

The following SEP is generated by Fluxtion. Note that the event processing OnEvent methods is inverted for cache and cache writer. The reader is notified of a change after the cache update, behaving as expected.

```java
public class SampleProcessor implements EventHandler, BatchHandler, Lifecycle {

  //Node declarations
  private final MyEventHandler myEventHandler_1 = new MyEventHandler();
  private final CacheWriter cacheWriter_7 = new CacheWriter(myEventHandler_1);
  private final Cache cache_3 = new Cache();
  private final CacheReader cacheReader_5 = new CacheReader(cache_3, myEventHandler_1);
  //omitted code for clarity

  public void handleEvent(MyEvent typedEvent) {
    //Default, no filter methods
    myEventHandler_1.handleEvent(typedEvent);
    cacheWriter_7.pushToCache();
    cache_3.reconcileCache();
    cacheReader_5.readFromCache();
    //event stack unwind callbacks
    afterEvent();
  }
}
```

 The graphical representation of this execution graph as generated by Fluxtion ESC, shows the cache and writer inverted:

![](../../.gitbook/assets/sampleprocessor.png)

